## Namespace ##
- Namespace allows us to group names entities that otherwise would have global scope into narrower spaces giving then name scope.
- Namespace is a declarative reason that provides a scope to the identifiers (name of types, function, variable etc.) inside it.
- Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in names scope.
```cpp
namespace My_namesapce{
    int x, y;
}
```
- Namespace declaration only appears at global scope.
- Namespace declaration can be nested within another namespace.
- Namespace declaration don't have access specifier (public or private).
- No need to give semicolon after the closing braces of definition of namespace.
- We can split the definition of namespace over several units.
- In each scope a name can only represent one entity. So there cannot be two variables with the same name in the same scope. Using namespace we can create two variables or member functions having the same name.
```cpp
// Example 1
namespace First{
    int val = 500;

}
int val  = 100;

int main(){
    int val = 200;
    cout << First::val << endl;
    return 0;
}
//output:
500
```
```cpp
//Example 2
namespace ns1{
    int value(){return 5;}
}

namespace ns2{
    int x = 20;
    int value(){return x*10;}
}

int main(){
    cout << ns1::value() << endl;
    cout << ns2::value() << endl;
    cout << ns2::x << endl;
    return 0;
}
// Output
5
200
20
```

- Class can be defined inside the namespace and outside as well
```cpp
namespace ns{
    class test;
}
class ns::test{
public:
    void display(){cout << "ns::test display()" << endl;}
};

int main(){
    ns::test obj;
    obj.display();
    return 0;
}
//output
ns::test:: display()
```
- We can also define the method outside namespace
```cpp
namespace ns{
    void display();
    class test{
        public:
            void display();
    };
}
void ns::display(){
    cout << "ns::display()" << endl;
}

void ns::test::display(){
    cout << "ns::test::display()" << endl;
}

int main(){
    ns::test obj;
    ns::display();
    obj.display();
    return 0;
}
//output
ns::display()
ns::test::display()
```
- extending namespaces using same namespace twice: It is possible to create the same namespace. The second namespace is the continuation of the first namespace.
```cpp
namespace first{
    int val1 = 500;
}

namespace first{
    int val2 = 700;
}

int main(){
    cout << first::val1 << endl;
    cout << first::val1 << endl;
}
//output
500
700
```

## unnamed namespace ##
- They are directly usable in the same program and are used for declaring unique identifier.
- The name of the namespace uniquely generated by the compiler.
- Unnamed namespace will not be accessible within the file you create it in.
- Unnamed namespace are the replacement for the static declaration of variables.

```cpp
namespace{
    int rel = 300;
}
int main(){
    cout << rel << endl;
}
//output
300
```
- Instead of importing entire namespace import truncated namespace
```cpp
using namespace std::crono;

auto start = high_performance_clock::now();
// Do something then
auto stop = high_performance_clock::now();

auto duration duration_cast<milliseconds> (stop-start);
```

-We can also use the statement for importing a single identifier for eg. import only std::cout we can use like:
```cpp
    using namespace std::cout;
```
- If you still import entire namespace try to do so inside function or limited scope and not in global scope.

```cpp
using namespace std; // global scope
void foo(){
    using namespace std; // local scope
}
```

